
// Code generated by MetaFFI. DO NOT EDIT.
// Host code for JavaExtractor.json
package JavaExtractor

import "fmt"
import "unsafe"
import . "github.com/MetaFFI/lang-plugin-go/go-runtime"

/*
#cgo !windows LDFLAGS: -L. -ldl
#cgo CFLAGS: -I"C:/src/github.com/MetaFFI/metaffi-core/out/windows/x64/debug"

#include <stdlib.h>
#include <stdint.h>
#include <include/cdt_structs.h>
#include <include/cdt_capi_loader.h>

metaffi_handle get_null_handle();
metaffi_size get_int_item(metaffi_size* array, int index);
void* convert_union_to_ptr(void* p);
void set_cdt_type(struct cdt* p, metaffi_type t);
metaffi_type get_cdt_type(struct cdt* p);
metaffi_size len_to_metaffi_size(long long i);
*/
import "C"



// function IDs








var VariableInfo_Name_id unsafe.Pointer


var VariableInfo_Type_id unsafe.Pointer


var VariableInfo_IsStatic_id unsafe.Pointer


var VariableInfo_IsFinal_id unsafe.Pointer





var VariableInfo_ReleaseVariableInfo_id unsafe.Pointer



var ParameterInfo_Name_id unsafe.Pointer


var ParameterInfo_Type_id unsafe.Pointer





var ParameterInfo_ReleaseParameterInfo_id unsafe.Pointer



var MethodInfo_Name_id unsafe.Pointer


var MethodInfo_IsStatic_id unsafe.Pointer


var MethodInfo_Comment_id unsafe.Pointer


var MethodInfo_Parameters_id unsafe.Pointer


var MethodInfo_ReturnValue_id unsafe.Pointer





var MethodInfo_ReleaseMethodInfo_id unsafe.Pointer



var ClassInfo_Name_id unsafe.Pointer


var ClassInfo_Comment_id unsafe.Pointer


var ClassInfo_Package_id unsafe.Pointer


var ClassInfo_Fields_id unsafe.Pointer


var ClassInfo_Methods_id unsafe.Pointer


var ClassInfo_Constructors_id unsafe.Pointer





var ClassInfo_ReleaseClassInfo_id unsafe.Pointer



var JavaInfo_Classes_id unsafe.Pointer





var JavaInfo_ReleaseJavaInfo_id unsafe.Pointer




var JavaExtractor_extract_id unsafe.Pointer


var JavaExtractor_JavaExtractor_id unsafe.Pointer


var JavaExtractor_ReleaseJavaExtractor_id unsafe.Pointer




func Load(modulePath string){
	loadCDTCAPI()

	runtime_plugin := "xllr.openjdk"
	pruntime_plugin := C.CString(runtime_plugin)
	runtime_plugin_length := C.uint32_t(len(runtime_plugin))

	// load foreign runtime
	var out_err *C.char
    var out_err_len C.uint32_t
    out_err_len = C.uint32_t(0)
	C.xllr_load_runtime_plugin(pruntime_plugin, runtime_plugin_length, &out_err, &out_err_len)
	if out_err_len != C.uint32_t(0){
		panic(fmt.Errorf("Failed to load runtime %v: %v", runtime_plugin, string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len)))))
	}

	// load functions
	loadFF := func(modulePath string, fpath string, params_count int, retval_count int) unsafe.Pointer{
		ppath := C.CString(fpath)
		defer C.free(unsafe.Pointer(ppath))

		pmodulePath := C.CString(modulePath)
		defer C.free(unsafe.Pointer(pmodulePath))

		var out_err *C.char
		var out_err_len C.uint32_t
		out_err_len = C.uint32_t(0)
		id := C.xllr_load_function(pruntime_plugin, runtime_plugin_length, pmodulePath, C.uint(len(modulePath)), ppath, C.uint(len(fpath)), nil,  C.schar(params_count), C.schar(params_count), &out_err, &out_err_len)

		if id == nil{ // failed
			panic(fmt.Errorf("Failed to load foreign entity entrypoint \"%v\": %v", fpath, string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len)))))
		}

		return id
	}

	
	

	

	
	
	VariableInfo_Name_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_get_Name,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	VariableInfo_Type_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_get_Type,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	VariableInfo_IsStatic_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_get_IsStatic,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	VariableInfo_IsFinal_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_get_IsFinal,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	VariableInfo_ReleaseVariableInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_ReleaseVariableInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	ParameterInfo_Name_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ParameterInfo_get_Name,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ParameterInfo_Type_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ParameterInfo_get_Type,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	ParameterInfo_ReleaseParameterInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ParameterInfo_ReleaseParameterInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	MethodInfo_Name_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_Name,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	MethodInfo_IsStatic_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_IsStatic,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	MethodInfo_Comment_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_Comment,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	MethodInfo_Parameters_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_Parameters,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	MethodInfo_ReturnValue_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_ReturnValue,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	MethodInfo_ReleaseMethodInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_ReleaseMethodInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	ClassInfo_Name_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Name,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Comment_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Comment,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Package_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Package,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Fields_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Fields,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Methods_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Methods,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Constructors_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Constructors,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	ClassInfo_ReleaseClassInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_ReleaseClassInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	JavaInfo_Classes_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaInfo_get_Classes,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	JavaInfo_ReleaseJavaInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaInfo_ReleaseJavaInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	
	JavaExtractor_extract_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaExtractor_extract,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	JavaExtractor_JavaExtractor_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaExtractor_JavaExtractor,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	JavaExtractor_ReleaseJavaExtractor_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaExtractor_ReleaseJavaExtractor,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
}

func Free(){
	runtime_plugin := "xllr.openjdk"
    pruntime_plugin := C.CString(runtime_plugin)
    runtime_plugin_length := C.uint32_t(len(runtime_plugin))

    var out_err *C.char
    var out_err_len C.uint32_t
    out_err_len = C.uint32_t(0)
    C.xllr_free_runtime_plugin(pruntime_plugin, runtime_plugin_length, &out_err, &out_err_len)
}









// Code to call foreign functions in module JavaExtractor via XLLR



type VariableInfo struct{
	h Handle
}



func (this *VariableInfo) GetHandle() Handle{
	return this.h
}



func (this *VariableInfo) Name() (name string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(VariableInfo_Name_id, xcall_params, &out_err, &out_err_len)  // call function pointer VariableInfo_Name_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	nameAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *VariableInfo) Type() (type__ string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(VariableInfo_Type_id, xcall_params, &out_err, &out_err_len)  // call function pointer VariableInfo_Type_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	type__AsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if type__AsInterface != nil{
		
		// not handle
		type__ = string(type__AsInterface.(string))
		
		
	}

	

	return type__, nil	
}




func (this *VariableInfo) IsStatic() (IsStatic bool, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(VariableInfo_IsStatic_id, xcall_params, &out_err, &out_err_len)  // call function pointer VariableInfo_IsStatic_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	IsStaticAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if IsStaticAsInterface != nil{
		
		// not handle
		IsStatic = bool(IsStaticAsInterface.(bool))
		
		
	}

	

	return IsStatic, nil	
}




func (this *VariableInfo) IsFinal() (IsFinal bool, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(VariableInfo_IsFinal_id, xcall_params, &out_err, &out_err_len)  // call function pointer VariableInfo_IsFinal_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	IsFinalAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if IsFinalAsInterface != nil{
		
		// not handle
		IsFinal = bool(IsFinalAsInterface.(bool))
		
		
	}

	

	return IsFinal, nil	
}





func (this *VariableInfo) ReleaseVariableInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(VariableInfo_ReleaseVariableInfo_id, xcall_params, &out_err, &out_err_len)  // call function pointer VariableInfo_ReleaseVariableInfo_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type ParameterInfo struct{
	h Handle
}



func (this *ParameterInfo) GetHandle() Handle{
	return this.h
}



func (this *ParameterInfo) Name() (name string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(ParameterInfo_Name_id, xcall_params, &out_err, &out_err_len)  // call function pointer ParameterInfo_Name_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	nameAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *ParameterInfo) Type() (type__ string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(ParameterInfo_Type_id, xcall_params, &out_err, &out_err_len)  // call function pointer ParameterInfo_Type_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	type__AsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if type__AsInterface != nil{
		
		// not handle
		type__ = string(type__AsInterface.(string))
		
		
	}

	

	return type__, nil	
}





func (this *ParameterInfo) ReleaseParameterInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(ParameterInfo_ReleaseParameterInfo_id, xcall_params, &out_err, &out_err_len)  // call function pointer ParameterInfo_ReleaseParameterInfo_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type MethodInfo struct{
	h Handle
}



func (this *MethodInfo) GetHandle() Handle{
	return this.h
}



func (this *MethodInfo) Name() (name string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(MethodInfo_Name_id, xcall_params, &out_err, &out_err_len)  // call function pointer MethodInfo_Name_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	nameAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *MethodInfo) IsStatic() (IsStatic bool, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(MethodInfo_IsStatic_id, xcall_params, &out_err, &out_err_len)  // call function pointer MethodInfo_IsStatic_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	IsStaticAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if IsStaticAsInterface != nil{
		
		// not handle
		IsStatic = bool(IsStaticAsInterface.(bool))
		
		
	}

	

	return IsStatic, nil	
}




func (this *MethodInfo) Comment() (Comment string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(MethodInfo_Comment_id, xcall_params, &out_err, &out_err_len)  // call function pointer MethodInfo_Comment_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	CommentAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if CommentAsInterface != nil{
		
		// not handle
		Comment = string(CommentAsInterface.(string))
		
		
	}

	

	return Comment, nil	
}




func (this *MethodInfo) Parameters() (Parameters []ParameterInfo, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(MethodInfo_Parameters_id, xcall_params, &out_err, &out_err_len)  // call function pointer MethodInfo_Parameters_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	ParametersAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if ParametersAsInterface != nil{
		 
		// handle
		
		 
		if len(ParametersAsInterface.([]interface{})) > 0{
			Parameters = make([]ParameterInfo, len(ParametersAsInterface.([]interface{})))
			if _, ok := ParametersAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range ParametersAsInterface.([]interface{}){
					Parameters[i] = ParameterInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range ParametersAsInterface.([]interface{}){
					Parameters[i] = obj.(ParameterInfo)
				}
			}
		}
		
		

		
	}

	

	return Parameters, nil	
}




func (this *MethodInfo) ReturnValue() (return_values ParameterInfo, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(MethodInfo_ReturnValue_id, xcall_params, &out_err, &out_err_len)  // call function pointer MethodInfo_ReturnValue_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	return_valuesAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if return_valuesAsInterface != nil{
		 
		// handle
		
		if obj, ok := return_valuesAsInterface.(Handle); ok{ // None Go object			
			return_values = ParameterInfo{ h: obj }
		} else {
			return_values = ParameterInfo(return_valuesAsInterface.(ParameterInfo))
		}
		

		
	}

	

	return return_values, nil	
}





func (this *MethodInfo) ReleaseMethodInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(MethodInfo_ReleaseMethodInfo_id, xcall_params, &out_err, &out_err_len)  // call function pointer MethodInfo_ReleaseMethodInfo_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type ClassInfo struct{
	h Handle
}



func (this *ClassInfo) GetHandle() Handle{
	return this.h
}



func (this *ClassInfo) Name() (name string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(ClassInfo_Name_id, xcall_params, &out_err, &out_err_len)  // call function pointer ClassInfo_Name_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	nameAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *ClassInfo) Comment() (Comment string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(ClassInfo_Comment_id, xcall_params, &out_err, &out_err_len)  // call function pointer ClassInfo_Comment_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	CommentAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if CommentAsInterface != nil{
		
		// not handle
		Comment = string(CommentAsInterface.(string))
		
		
	}

	

	return Comment, nil	
}




func (this *ClassInfo) Package() (Package string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(ClassInfo_Package_id, xcall_params, &out_err, &out_err_len)  // call function pointer ClassInfo_Package_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	PackageAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if PackageAsInterface != nil{
		
		// not handle
		Package = string(PackageAsInterface.(string))
		
		
	}

	

	return Package, nil	
}




func (this *ClassInfo) Fields() (fields []VariableInfo, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(ClassInfo_Fields_id, xcall_params, &out_err, &out_err_len)  // call function pointer ClassInfo_Fields_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	fieldsAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if fieldsAsInterface != nil{
		 
		// handle
		
		 
		if len(fieldsAsInterface.([]interface{})) > 0{
			fields = make([]VariableInfo, len(fieldsAsInterface.([]interface{})))
			if _, ok := fieldsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range fieldsAsInterface.([]interface{}){
					fields[i] = VariableInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range fieldsAsInterface.([]interface{}){
					fields[i] = obj.(VariableInfo)
				}
			}
		}
		
		

		
	}

	

	return fields, nil	
}




func (this *ClassInfo) Methods() (methods []MethodInfo, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(ClassInfo_Methods_id, xcall_params, &out_err, &out_err_len)  // call function pointer ClassInfo_Methods_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	methodsAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if methodsAsInterface != nil{
		 
		// handle
		
		 
		if len(methodsAsInterface.([]interface{})) > 0{
			methods = make([]MethodInfo, len(methodsAsInterface.([]interface{})))
			if _, ok := methodsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range methodsAsInterface.([]interface{}){
					methods[i] = MethodInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range methodsAsInterface.([]interface{}){
					methods[i] = obj.(MethodInfo)
				}
			}
		}
		
		

		
	}

	

	return methods, nil	
}




func (this *ClassInfo) Constructors() (constructors []MethodInfo, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(ClassInfo_Constructors_id, xcall_params, &out_err, &out_err_len)  // call function pointer ClassInfo_Constructors_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	constructorsAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if constructorsAsInterface != nil{
		 
		// handle
		
		 
		if len(constructorsAsInterface.([]interface{})) > 0{
			constructors = make([]MethodInfo, len(constructorsAsInterface.([]interface{})))
			if _, ok := constructorsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range constructorsAsInterface.([]interface{}){
					constructors[i] = MethodInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range constructorsAsInterface.([]interface{}){
					constructors[i] = obj.(MethodInfo)
				}
			}
		}
		
		

		
	}

	

	return constructors, nil	
}





func (this *ClassInfo) ReleaseClassInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(ClassInfo_ReleaseClassInfo_id, xcall_params, &out_err, &out_err_len)  // call function pointer ClassInfo_ReleaseClassInfo_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type JavaInfo struct{
	h Handle
}



func (this *JavaInfo) GetHandle() Handle{
	return this.h
}



func (this *JavaInfo) Classes() (classes []ClassInfo, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(JavaInfo_Classes_id, xcall_params, &out_err, &out_err_len)  // call function pointer JavaInfo_Classes_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	classesAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if classesAsInterface != nil{
		 
		// handle
		
		 
		if len(classesAsInterface.([]interface{})) > 0{
			classes = make([]ClassInfo, len(classesAsInterface.([]interface{})))
			if _, ok := classesAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range classesAsInterface.([]interface{}){
					classes[i] = ClassInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range classesAsInterface.([]interface{}){
					classes[i] = obj.(ClassInfo)
				}
			}
		}
		
		

		
	}

	

	return classes, nil	
}





func (this *JavaInfo) ReleaseJavaInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(JavaInfo_ReleaseJavaInfo_id, xcall_params, &out_err, &out_err_len)  // call function pointer JavaInfo_ReleaseJavaInfo_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type JavaExtractor struct{
	h Handle
}


func NewJavaExtractor( filename string) (instance *JavaExtractor, err error){
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// parameters
	
	fromGoToCDT(filename, parametersCDTS, 0)
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(JavaExtractor_JavaExtractor_id, xcall_params, &out_err, &out_err_len)  // call function pointer JavaExtractor_JavaExtractor_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	inst := &JavaExtractor{}

	
	new_instanceAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if new_instanceAsInterface != nil{
		inst.h = new_instanceAsInterface.(Handle)
	} else {
		return nil, fmt.Errorf("Object creation returned nil")
	}
		
	

	return inst, nil	
}


func (this *JavaExtractor) GetHandle() Handle{
	return this.h
}



func (this *JavaExtractor) Extract() (info JavaInfo, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(JavaExtractor_extract_id, xcall_params, &out_err, &out_err_len)  // call function pointer JavaExtractor_extract_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	infoAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if infoAsInterface != nil{
		 		
		
		
		
		if obj, ok := infoAsInterface.(Handle); ok{ // None Go object			
			info = JavaInfo{ h: obj }
		} else {
			info = JavaInfo(infoAsInterface.(JavaInfo))
		}
		

		
	}
	
	

	return info, nil
}


func (this *JavaExtractor) ReleaseJavaExtractor( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(JavaExtractor_ReleaseJavaExtractor_id, xcall_params, &out_err, &out_err_len)  // call function pointer JavaExtractor_ReleaseJavaExtractor_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}




