
// Code generated by MetaFFI. DO NOT EDIT.
// Host code for JavaExtractor.json
package JavaExtractor

import "fmt"
import "unsafe"
import . "github.com/MetaFFI/lang-plugin-go/go-runtime"



// function IDs








var VariableInfo_Name_id unsafe.Pointer


var VariableInfo_Type_id unsafe.Pointer


var VariableInfo_IsStatic_id unsafe.Pointer


var VariableInfo_IsFinal_id unsafe.Pointer





var VariableInfo_ReleaseVariableInfo_id unsafe.Pointer



var ParameterInfo_Name_id unsafe.Pointer


var ParameterInfo_Type_id unsafe.Pointer





var ParameterInfo_ReleaseParameterInfo_id unsafe.Pointer



var MethodInfo_Name_id unsafe.Pointer


var MethodInfo_IsStatic_id unsafe.Pointer


var MethodInfo_Comment_id unsafe.Pointer


var MethodInfo_Parameters_id unsafe.Pointer


var MethodInfo_ReturnValue_id unsafe.Pointer





var MethodInfo_ReleaseMethodInfo_id unsafe.Pointer



var ClassInfo_Name_id unsafe.Pointer


var ClassInfo_Comment_id unsafe.Pointer


var ClassInfo_Package_id unsafe.Pointer


var ClassInfo_Fields_id unsafe.Pointer


var ClassInfo_Methods_id unsafe.Pointer


var ClassInfo_Constructors_id unsafe.Pointer





var ClassInfo_ReleaseClassInfo_id unsafe.Pointer



var JavaInfo_Classes_id unsafe.Pointer





var JavaInfo_ReleaseJavaInfo_id unsafe.Pointer




var JavaExtractor_extract_id unsafe.Pointer


var JavaExtractor_JavaExtractor_id unsafe.Pointer


var JavaExtractor_ReleaseJavaExtractor_id unsafe.Pointer




func Load(modulePath string){
	LoadCDTCAPI()

	runtimePlugin := "xllr.openjdk"
	err := XLLRLoadRuntimePlugin(runtimePlugin)
	if err != nil{
		panic(err)
	}

	// load functions
	loadFF := func(modulePath string, fpath string, paramsCount int8, retvalCount int8) unsafe.Pointer{
		id, err := XLLRLoadFunction(runtimePlugin, modulePath, fpath, nil, paramsCount, retvalCount)
		if err != nil{ // failed
			panic(err)
		}

		return id
	}

	
	

	

	
	
	VariableInfo_Name_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_get_Name,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	VariableInfo_Type_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_get_Type,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	VariableInfo_IsStatic_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_get_IsStatic,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	VariableInfo_IsFinal_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_get_IsFinal,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	VariableInfo_ReleaseVariableInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_VariableInfo_ReleaseVariableInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	ParameterInfo_Name_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ParameterInfo_get_Name,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ParameterInfo_Type_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ParameterInfo_get_Type,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	ParameterInfo_ReleaseParameterInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ParameterInfo_ReleaseParameterInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	MethodInfo_Name_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_Name,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	MethodInfo_IsStatic_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_IsStatic,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	MethodInfo_Comment_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_Comment,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	MethodInfo_Parameters_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_Parameters,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	MethodInfo_ReturnValue_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_get_ReturnValue,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	MethodInfo_ReleaseMethodInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_MethodInfo_ReleaseMethodInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	ClassInfo_Name_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Name,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Comment_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Comment,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Package_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Package,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Fields_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Fields,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Methods_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Methods,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	ClassInfo_Constructors_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_get_Constructors,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	ClassInfo_ReleaseClassInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_ClassInfo_ReleaseClassInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	JavaInfo_Classes_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaInfo_get_Classes,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	
	
	
	JavaInfo_ReleaseJavaInfo_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaInfo_ReleaseJavaInfo,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
	
	JavaExtractor_extract_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaExtractor_extract,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	JavaExtractor_JavaExtractor_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaExtractor_JavaExtractor,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 1)
	
	
	JavaExtractor_ReleaseJavaExtractor_id = loadFF(modulePath, `entrypoint_class=JavaExtractor_Entrypoints,entrypoint_function=EntryPoint_JavaExtractor_ReleaseJavaExtractor,metaffi_guest_lib=JavaExtractor_MetaFFIGuest,module=JavaExtractor,package=java_extractor`, 1, 0)
	
	
	
}

func Free(){
	err := XLLRFreeRuntimePlugin("xllr.openjdk")
	if err != nil{ panic(err) }
}









// Code to call foreign functions in module JavaExtractor via XLLR



type VariableInfo struct{
	h Handle
}



func (this *VariableInfo) GetHandle() Handle{
	return this.h
}

func (this *VariableInfo) SetHandle(h Handle){
	this.h = h
}



func (this *VariableInfo) Name() (name string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(VariableInfo_Name_id, xcall_params)  // call function pointer VariableInfo_Name_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionVariableInfo.Name. Error: %v", err)
		return
	}

	
	
	nameAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *VariableInfo) Type() (type__ string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(VariableInfo_Type_id, xcall_params)  // call function pointer VariableInfo_Type_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionVariableInfo.Type. Error: %v", err)
		return
	}

	
	
	type__AsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if type__AsInterface != nil{
		
		// not handle
		type__ = string(type__AsInterface.(string))
		
		
	}

	

	return type__, nil	
}




func (this *VariableInfo) IsStatic() (IsStatic bool, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(VariableInfo_IsStatic_id, xcall_params)  // call function pointer VariableInfo_IsStatic_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionVariableInfo.IsStatic. Error: %v", err)
		return
	}

	
	
	IsStaticAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if IsStaticAsInterface != nil{
		
		// not handle
		IsStatic = bool(IsStaticAsInterface.(bool))
		
		
	}

	

	return IsStatic, nil	
}




func (this *VariableInfo) IsFinal() (IsFinal bool, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(VariableInfo_IsFinal_id, xcall_params)  // call function pointer VariableInfo_IsFinal_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionVariableInfo.IsFinal. Error: %v", err)
		return
	}

	
	
	IsFinalAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if IsFinalAsInterface != nil{
		
		// not handle
		IsFinal = bool(IsFinalAsInterface.(bool))
		
		
	}

	

	return IsFinal, nil	
}





func (this *VariableInfo) ReleaseVariableInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(VariableInfo_ReleaseVariableInfo_id, xcall_params)  // call function pointer VariableInfo_ReleaseVariableInfo_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionVariableInfo.ReleaseVariableInfo. Error: %v", err)
		return
	}

	
	

	return  nil
}


type ParameterInfo struct{
	h Handle
}



func (this *ParameterInfo) GetHandle() Handle{
	return this.h
}

func (this *ParameterInfo) SetHandle(h Handle){
	this.h = h
}



func (this *ParameterInfo) Name() (name string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(ParameterInfo_Name_id, xcall_params)  // call function pointer ParameterInfo_Name_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionParameterInfo.Name. Error: %v", err)
		return
	}

	
	
	nameAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *ParameterInfo) Type() (type__ string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(ParameterInfo_Type_id, xcall_params)  // call function pointer ParameterInfo_Type_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionParameterInfo.Type. Error: %v", err)
		return
	}

	
	
	type__AsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if type__AsInterface != nil{
		
		// not handle
		type__ = string(type__AsInterface.(string))
		
		
	}

	

	return type__, nil	
}





func (this *ParameterInfo) ReleaseParameterInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(ParameterInfo_ReleaseParameterInfo_id, xcall_params)  // call function pointer ParameterInfo_ReleaseParameterInfo_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionParameterInfo.ReleaseParameterInfo. Error: %v", err)
		return
	}

	
	

	return  nil
}


type MethodInfo struct{
	h Handle
}



func (this *MethodInfo) GetHandle() Handle{
	return this.h
}

func (this *MethodInfo) SetHandle(h Handle){
	this.h = h
}



func (this *MethodInfo) Name() (name string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(MethodInfo_Name_id, xcall_params)  // call function pointer MethodInfo_Name_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionMethodInfo.Name. Error: %v", err)
		return
	}

	
	
	nameAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *MethodInfo) IsStatic() (IsStatic bool, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(MethodInfo_IsStatic_id, xcall_params)  // call function pointer MethodInfo_IsStatic_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionMethodInfo.IsStatic. Error: %v", err)
		return
	}

	
	
	IsStaticAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if IsStaticAsInterface != nil{
		
		// not handle
		IsStatic = bool(IsStaticAsInterface.(bool))
		
		
	}

	

	return IsStatic, nil	
}




func (this *MethodInfo) Comment() (Comment string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(MethodInfo_Comment_id, xcall_params)  // call function pointer MethodInfo_Comment_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionMethodInfo.Comment. Error: %v", err)
		return
	}

	
	
	CommentAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if CommentAsInterface != nil{
		
		// not handle
		Comment = string(CommentAsInterface.(string))
		
		
	}

	

	return Comment, nil	
}




func (this *MethodInfo) Parameters() (Parameters []ParameterInfo, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(MethodInfo_Parameters_id, xcall_params)  // call function pointer MethodInfo_Parameters_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionMethodInfo.Parameters. Error: %v", err)
		return
	}

	
	
	ParametersAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if ParametersAsInterface != nil{
		 
		// handle
		
		 
		if len(ParametersAsInterface.([]interface{})) > 0{
			Parameters = make([]ParameterInfo, len(ParametersAsInterface.([]interface{})))
			if _, ok := ParametersAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range ParametersAsInterface.([]interface{}){
					Parameters[i] = ParameterInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range ParametersAsInterface.([]interface{}){
					Parameters[i] = obj.(ParameterInfo)
				}
			}
		}
		
		

		
	}

	

	return Parameters, nil	
}




func (this *MethodInfo) ReturnValue() (return_values ParameterInfo, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(MethodInfo_ReturnValue_id, xcall_params)  // call function pointer MethodInfo_ReturnValue_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionMethodInfo.ReturnValue. Error: %v", err)
		return
	}

	
	
	return_valuesAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if return_valuesAsInterface != nil{
		 
		// handle
		
		if obj, ok := return_valuesAsInterface.(Handle); ok{ // None Go object			
			return_values = ParameterInfo{ h: obj }
		} else {
			return_values = ParameterInfo(return_valuesAsInterface.(ParameterInfo))
		}
		

		
	}

	

	return return_values, nil	
}





func (this *MethodInfo) ReleaseMethodInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(MethodInfo_ReleaseMethodInfo_id, xcall_params)  // call function pointer MethodInfo_ReleaseMethodInfo_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionMethodInfo.ReleaseMethodInfo. Error: %v", err)
		return
	}

	
	

	return  nil
}


type ClassInfo struct{
	h Handle
}



func (this *ClassInfo) GetHandle() Handle{
	return this.h
}

func (this *ClassInfo) SetHandle(h Handle){
	this.h = h
}



func (this *ClassInfo) Name() (name string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(ClassInfo_Name_id, xcall_params)  // call function pointer ClassInfo_Name_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionClassInfo.Name. Error: %v", err)
		return
	}

	
	
	nameAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *ClassInfo) Comment() (Comment string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(ClassInfo_Comment_id, xcall_params)  // call function pointer ClassInfo_Comment_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionClassInfo.Comment. Error: %v", err)
		return
	}

	
	
	CommentAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if CommentAsInterface != nil{
		
		// not handle
		Comment = string(CommentAsInterface.(string))
		
		
	}

	

	return Comment, nil	
}




func (this *ClassInfo) Package() (Package string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(ClassInfo_Package_id, xcall_params)  // call function pointer ClassInfo_Package_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionClassInfo.Package. Error: %v", err)
		return
	}

	
	
	PackageAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if PackageAsInterface != nil{
		
		// not handle
		Package = string(PackageAsInterface.(string))
		
		
	}

	

	return Package, nil	
}




func (this *ClassInfo) Fields() (fields []VariableInfo, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(ClassInfo_Fields_id, xcall_params)  // call function pointer ClassInfo_Fields_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionClassInfo.Fields. Error: %v", err)
		return
	}

	
	
	fieldsAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if fieldsAsInterface != nil{
		 
		// handle
		
		 
		if len(fieldsAsInterface.([]interface{})) > 0{
			fields = make([]VariableInfo, len(fieldsAsInterface.([]interface{})))
			if _, ok := fieldsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range fieldsAsInterface.([]interface{}){
					fields[i] = VariableInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range fieldsAsInterface.([]interface{}){
					fields[i] = obj.(VariableInfo)
				}
			}
		}
		
		

		
	}

	

	return fields, nil	
}




func (this *ClassInfo) Methods() (methods []MethodInfo, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(ClassInfo_Methods_id, xcall_params)  // call function pointer ClassInfo_Methods_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionClassInfo.Methods. Error: %v", err)
		return
	}

	
	
	methodsAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if methodsAsInterface != nil{
		 
		// handle
		
		 
		if len(methodsAsInterface.([]interface{})) > 0{
			methods = make([]MethodInfo, len(methodsAsInterface.([]interface{})))
			if _, ok := methodsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range methodsAsInterface.([]interface{}){
					methods[i] = MethodInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range methodsAsInterface.([]interface{}){
					methods[i] = obj.(MethodInfo)
				}
			}
		}
		
		

		
	}

	

	return methods, nil	
}




func (this *ClassInfo) Constructors() (constructors []MethodInfo, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(ClassInfo_Constructors_id, xcall_params)  // call function pointer ClassInfo_Constructors_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionClassInfo.Constructors. Error: %v", err)
		return
	}

	
	
	constructorsAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if constructorsAsInterface != nil{
		 
		// handle
		
		 
		if len(constructorsAsInterface.([]interface{})) > 0{
			constructors = make([]MethodInfo, len(constructorsAsInterface.([]interface{})))
			if _, ok := constructorsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range constructorsAsInterface.([]interface{}){
					constructors[i] = MethodInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range constructorsAsInterface.([]interface{}){
					constructors[i] = obj.(MethodInfo)
				}
			}
		}
		
		

		
	}

	

	return constructors, nil	
}





func (this *ClassInfo) ReleaseClassInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(ClassInfo_ReleaseClassInfo_id, xcall_params)  // call function pointer ClassInfo_ReleaseClassInfo_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionClassInfo.ReleaseClassInfo. Error: %v", err)
		return
	}

	
	

	return  nil
}


type JavaInfo struct{
	h Handle
}



func (this *JavaInfo) GetHandle() Handle{
	return this.h
}

func (this *JavaInfo) SetHandle(h Handle){
	this.h = h
}



func (this *JavaInfo) Classes() (classes []ClassInfo, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(JavaInfo_Classes_id, xcall_params)  // call function pointer JavaInfo_Classes_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionJavaInfo.Classes. Error: %v", err)
		return
	}

	
	
	classesAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if classesAsInterface != nil{
		 
		// handle
		
		 
		if len(classesAsInterface.([]interface{})) > 0{
			classes = make([]ClassInfo, len(classesAsInterface.([]interface{})))
			if _, ok := classesAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range classesAsInterface.([]interface{}){
					classes[i] = ClassInfo{ h: h.(Handle) }
				}
			} else {
				for i, obj := range classesAsInterface.([]interface{}){
					classes[i] = obj.(ClassInfo)
				}
			}
		}
		
		

		
	}

	

	return classes, nil	
}





func (this *JavaInfo) ReleaseJavaInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(JavaInfo_ReleaseJavaInfo_id, xcall_params)  // call function pointer JavaInfo_ReleaseJavaInfo_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionJavaInfo.ReleaseJavaInfo. Error: %v", err)
		return
	}

	
	

	return  nil
}


type JavaExtractor struct{
	h Handle
}


func NewJavaExtractor( filename string) (instance *JavaExtractor, err error){
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// parameters
	
	FromGoToCDT(filename, parametersCDTS, 0)
	

		err = XLLRXCallParamsRet(JavaExtractor_JavaExtractor_id, xcall_params)  // call function pointer JavaExtractor_JavaExtractor_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionJavaExtractor.JavaExtractor. Error: %v", err)
		return
	}

	
	inst := &JavaExtractor{}

	
	new_instanceAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if new_instanceAsInterface != nil{
		inst.h = new_instanceAsInterface.(Handle)
	} else {
		return nil, fmt.Errorf("Object creation returned nil")
	}
		
	

	return inst, nil	
}


func (this *JavaExtractor) GetHandle() Handle{
	return this.h
}

func (this *JavaExtractor) SetHandle(h Handle){
	this.h = h
}



func (this *JavaExtractor) Extract() (info JavaInfo, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	
	

		err = XLLRXCallParamsRet(JavaExtractor_extract_id, xcall_params)  // call function pointer JavaExtractor_extract_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionJavaExtractor.extract. Error: %v", err)
		return
	}

	
	
	infoAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if infoAsInterface != nil{
		 		
		
		
		
		if obj, ok := infoAsInterface.(Handle); ok{ // None Go object			
			info = JavaInfo{ h: obj }
		} else {
			info = JavaInfo(infoAsInterface.(JavaInfo))
		}
		

		
	}
	
	

	return info, nil
}


func (this *JavaExtractor) ReleaseJavaExtractor( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(JavaExtractor_ReleaseJavaExtractor_id, xcall_params)  // call function pointer JavaExtractor_ReleaseJavaExtractor_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionJavaExtractor.ReleaseJavaExtractor. Error: %v", err)
		return
	}

	
	

	return  nil
}




