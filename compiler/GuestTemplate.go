package main

const GuestHeaderTemplate = `
// Code generated by MetaFFI.
// Guest code for {{.IDLFilenameWithExtension}}
`

const GuestPackage = `package metaffi_guest;
`

const GuestImportsTemplate = `
import java.io.*;
import java.util.*;
import metaffi.*;
{{GetImports .}}
`

const GuestFunctionXLLRTemplate = `
{{$idlFilename := .IDLFilename}}
{{range $mindex, $m := .Modules}}


// Code to call foreign functions in module {{$m.Name}}
public final class {{$m.Name}}_Entrypoints
{
	private static MetaFFIBridge metaffiBridge = new MetaFFIBridge();

	// Globals
	{{if $m.Globals}}
	{{Panic "OpenJDK does not support global variables"}}
	{{end}}
 
	{{if $m.Functions}}
	{{Panic "OpenJDK does not support global functions"}}
	{{end}}
	
	// classes entities
	{{range $cindex, $c := $m.Classes}}

	{{range $findex, $field := $c.Fields}}
	{{if $field.Getter}}{{$retvalLength := len $field.Getter.ReturnValues}}{{$f := $field.Getter}}
    {{ReturnValuesClass $f.Name $f.ReturnValues 1}}{{$returnValuesTypeName := ReturnValuesClassName $f.Name}}
    public static void EntryPoint_{{$c.Name}}_get_{{$f.Name}}(long xcall_params) throws MetaFFIException, Exception
	{
		{{GetCDTSPointers $f.Parameters $f.ReturnValues 2}}

		{{GetParamsFromCDTS $f.Parameters 2}}

		// get object instance
		{{GetObject $c $f}}

		{{if $f.ReturnValues}}
		metaffiBridge.java_to_cdts(return_valuesCDTS, new Object[]{ {{if not $f.InstanceRequired}}{{$c.Name}}{{else}}instance{{end}}.{{$field.Name}} }, {{GetMetaFFITypes $f.ReturnValues}} );
		{{end}}
	}
	{{end}} {{/* End getter */}}

	{{if $field.Setter}}{{$f := $field.Setter}}{{$retvalLength := len $f.ReturnValues}}
    {{ReturnValuesClass $f.Name $f.ReturnValues 1}}{{$returnValuesTypeName := ReturnValuesClassName $f.Name}}
    public static void EntryPoint_{{$c.Name}}_set_{{$f.Name}}(long xcall_params) throws MetaFFIException, Exception
    {
        {{GetCDTSPointers $f.Parameters $f.ReturnValues 2}}

		{{GetParamsFromCDTS $f.Parameters 2}}

		// get object instance
		{{GetObject $c $f}}

		{{if not $f.InstanceRequired}}{{$c.Name}}{{else}}instance{{end}}.{{$field.Name}} = ({{ToJavaType $field.Type $field.Dimensions}})parameters[1];
    }
    {{end}} {{/* End setter */}}
    {{end}} {{/*End Fields*/}}

	{{range $cstrindex, $f := $c.Constructors}}
	public static void EntryPoint_{{$c.Name}}_{{$f.Name}}(long xcall_params) throws MetaFFIException, Exception
	{
		{{GetCDTSPointers $f.Parameters $f.ReturnValues 2}}

		{{GetParamsFromCDTS $f.Parameters 2}}

		// get object instance
		{{CallConstructor $c $f}}

		{{if $f.ReturnValues}}
        metaffiBridge.java_to_cdts(return_valuesCDTS, new Object[]{ instance }, {{GetMetaFFITypes $f.ReturnValues}} );
        {{end}}
	}
	{{end}}

	{{if $c.Releaser}}{{$f := $c.Releaser}}
	public static void EntryPoint_{{$c.Name}}_{{$f.Name}}(long xcall_params) throws MetaFFIException, Exception
	{
		{{GetCDTSPointers $f.Parameters $f.ReturnValues 2}}

		{{GetParamsFromCDTS $f.Parameters 2}}

		metaffiBridge.remove_object((Long)parameters[0]);
	}
    {{end}} {{/*End Releaser*/}}

	{{/* Methods */}}
	{{range $findex, $f := $c.Methods}}

	{{$retvalLength := len $f.ReturnValues}}{{$paramsLength := len $f.Parameters}}
	public static void EntryPoint_{{$c.Name}}_{{$f.Name}}(long xcall_params) throws MetaFFIException, Exception
	{
		{{GetCDTSPointers $f.Parameters $f.ReturnValues 2}}

		{{GetParamsFromCDTS $f.Parameters 2}}

		// call method
		{{GetObject $c $f}}
		{{ CallGuestMethod $f 2 }}

		{{if $f.ReturnValues}}
        metaffiBridge.java_to_cdts(return_valuesCDTS, new Object[]{ result }, {{GetMetaFFITypes $f.ReturnValues}} );
        {{end}}
	}
	{{end}} {{/*End Methods*/}}
	{{end}} {{/*End Classes*/}}

}
{{end}}
`

const GuestCPPEntrypoint = `
#ifdef _DEBUG
#undef _DEBUG
#include <jni.h>
#define _DEBUG
#else
#include <jni.h>
#endif
#include <string>
#include <stdexcept>
#include <functional>
#include <regex>
#include <vector>
#include <set>
#include <unordered_map>
#include <cdt_structs.h>
#include <sstream>

#ifndef _WIN32
#include <dlfcn.h>
#else
#include <Windows.h>
#endif

{{/* Load entrypoints module function which loads all the entrypoints */}}

JavaVM* jvm = nullptr;


#define check_and_throw_jvm_exception(env, var, before_throw_code) \
if(env->ExceptionCheck() == JNI_TRUE)\
{\
std::string err_msg = get_exception_description(env, env->ExceptionOccurred());\
env->ExceptionClear();\
before_throw_code \
throw std::runtime_error(err_msg);\
}\
else if(!var)\
{\
before_throw_code; \
throw std::runtime_error("Failed to get " #var);\
}

#define if_exception_throw_jvm_exception(env, before_throw_code) \
if(env->ExceptionCheck() == JNI_TRUE)\
{\
std::string err_msg = get_exception_description(env, env->ExceptionOccurred());\
env->ExceptionClear();\
before_throw_code; \
throw std::runtime_error(err_msg);\
}

struct block_guard
{
	block_guard(std::function<void()> f):f(f){}
	~block_guard()
	{
		try{ f(); } catch(...){printf("block_guard function threw an exception\n");}
	}

private:
	std::function<void()> f;
};

std::string get_exception_description(JNIEnv* penv, jthrowable throwable)
{
	jclass throwable_class = penv->FindClass("java/lang/Throwable");
	if(!throwable_class)
	{
		throw std::runtime_error("failed to FindClass java/lang/Throwable");
	}

	jclass StringWriter_class = penv->FindClass("java/io/StringWriter");
    if(!StringWriter_class)
    {
        throw std::runtime_error("failed to FindClass java/io/StringWriter");
    }

	jclass PrintWriter_class = penv->FindClass("java/io/PrintWriter");
    if(!PrintWriter_class)
    {
        throw std::runtime_error("failed to FindClass java/io/PrintWriter");
    }

	jmethodID throwable_printStackTrace = penv->GetMethodID(throwable_class,"printStackTrace","(Ljava/io/PrintWriter;)V");
	if(!throwable_printStackTrace)
    {
        throw std::runtime_error("failed to GetMethodID throwable_printStackTrace");
    }

    jmethodID StringWriter_Constructor = penv->GetMethodID(StringWriter_class,"<init>","()V");
	if(!StringWriter_Constructor)
    {
        throw std::runtime_error("failed to GetMethodID StringWriter_Constructor");
    }

    jmethodID PrintWriter_Constructor = penv->GetMethodID(PrintWriter_class,"<init>","(Ljava/io/Writer;)V");
    if(!PrintWriter_Constructor)
    {
        throw std::runtime_error("failed to GetMethodID PrintWriter_Constructor");
    }

    jmethodID StringWriter_toString = penv->GetMethodID(StringWriter_class,"toString","()Ljava/lang/String;");
    if(!StringWriter_toString)
    {
        throw std::runtime_error("failed to GetMethodID StringWriter_toString");
    }

	// StringWriter sw = new StringWriter();
	jobject sw = penv->NewObject(StringWriter_class, StringWriter_Constructor);
	if(!sw)
    {
        throw std::runtime_error("Failed to create StringWriter object");
    }

    // PrintWriter pw = new PrintWriter(sw)
    jobject pw = penv->NewObject(PrintWriter_class, PrintWriter_Constructor, sw);
	if(!pw)
    {
        throw std::runtime_error("Failed to create PrintWriter object");
    }

    // throwable.printStackTrace(pw);
	penv->CallObjectMethod(throwable, throwable_printStackTrace, pw);
    if(!pw)
    {
        throw std::runtime_error("Failed to call printStackTrace");
    }

	// sw.toString()
	jobject str = penv->CallObjectMethod(sw, StringWriter_toString);
    if(!pw)
    {
        throw std::runtime_error("Failed to call printStackTrace");
    }

	std::string res(penv->GetStringUTFChars((jstring)str, nullptr));

	penv->DeleteLocalRef(sw);
	penv->DeleteLocalRef(pw);
	penv->DeleteLocalRef(str);

	return res;
}

typedef jclass (*load_class_t)(JNIEnv* env, const std::vector<std::string>& path, const char* class_name);
load_class_t load_class = nullptr;

std::function<void()> get_environment(JNIEnv** env)
{
	bool did_attach_thread = false;
	// Check if the current thread is attached to the VM
	auto get_env_result = jvm->GetEnv((void**)env, JNI_VERSION_10);
	if (get_env_result == JNI_EDETACHED)
	{
		if(jvm->AttachCurrentThread((void**)env, nullptr) == JNI_OK)
		{
			did_attach_thread = true;
		}
		else
		{
			// Failed to attach thread. Throw an exception if you want to.
			throw std::runtime_error("Failed to attach environment to current thread");
		}
	}
	else if (get_env_result == JNI_EVERSION)
	{
		// Unsupported JNI version. Throw an exception if you want to.
		throw std::runtime_error("Failed to get JVM environment - unsupported JNI version");
	}

	return did_attach_thread ? std::function<void()>([](){ jvm->DetachCurrentThread(); }) : [](){};
}


{{range $mindex, $m := .Modules}}
    {{range $cindex, $c := $m.Classes}}

        {{range $findex, $f := $c.Fields}}
            {{if $f.Getter}}{{$f := $f.Getter}}
jclass jclass_{{$c.Name}}_get_{{$f.Name}} = nullptr;
jmethodID jmethod_{{$c.Name}}_get_{{$f.Name}} = nullptr;
            {{end}}
            {{if $f.Setter}}{{$f := $f.Setter}}
jclass jclass_{{$c.Name}}_set_{{$f.Name}} = nullptr;
jmethodID jmethod_{{$c.Name}}_set_{{$f.Name}} = nullptr;
            {{end}}
        {{end}}

        {{range $cstrindex, $f := $c.Constructors}}
jclass jclass_{{$c.Name}}_{{$f.Name}} = nullptr;
jmethodID jmethod_{{$c.Name}}_{{$f.Name}} = nullptr;
        {{end}}

        {{if $c.Releaser}}{{$f := $c.Releaser}}
jclass jclass_{{$c.Name}}_{{$f.Name}} = nullptr;
jmethodID jmethod_{{$c.Name}}_{{$f.Name}} = nullptr;
        {{end}}

        {{range $cstrindex, $f := $c.Methods}}
jclass jclass_{{$c.Name}}_{{$f.Name}} = nullptr;
jmethodID jmethod_{{$c.Name}}_{{$f.Name}} = nullptr;
        {{end}}

	{{end}}
{{end}}

const char* get_dynamic_lib_suffix()
{
#if _WIN32
	return ".dll";
#elif __apple__
	return ".dylib";
#else
	return ".so";
#endif
}

void load_load_class()
{
	std::string openjdk_plugin_path(std::getenv("METAFFI_HOME"));
	openjdk_plugin_path += "/xllr.openjdk";
	openjdk_plugin_path += get_dynamic_lib_suffix();

#ifdef _WIN32
	HMODULE openjdk_plugin_handle = LoadLibrary(openjdk_plugin_path.c_str());
#else
	void* openjdk_plugin_handle = dlopen(openjdk_plugin_path.c_str(), RTLD_NOW | RTLD_GLOBAL);
#endif

	if(!openjdk_plugin_handle)
	{
		std::stringstream ss;
		ss << "Failed to load openjdk plugin at path: \"" << openjdk_plugin_path << "\". Error: ";
#ifdef _WIN32
		ss << GetLastError();
#else
		ss << dlerror();
#endif
	    ss << std::endl;

		throw std::runtime_error(ss.str());
	}

#ifdef _WIN32
	load_class = (load_class_t)GetProcAddress(openjdk_plugin_handle, "load_class");
#else
	load_class = (load_class_t)dlsym(openjdk_plugin_handle, "load_class");
#endif

	if(!load_class)
	{
        std::stringstream ss;
        ss << "Failed to load load_class function. Error: ";

#ifdef _WIN32
        ss << GetLastError();
#else
        ss << dlerror();
#endif
        ss << std::endl;

        throw std::runtime_error(ss.str());
    }

}

extern "C" void load_entrypoints(JavaVM* pjvm, JNIEnv* env)
{
	// load "load_class" function
	load_load_class();

	jvm = pjvm;
    {{range $mindex, $m := .Modules}}
        {{range $cindex, $c := $m.Classes}}

            {{range $findex, $field := $c.Fields}}
                {{if $field.Getter}}{{$f := $field.Getter}}
				{{if IsExternalResources $m}}
                jclass_{{$c.Name}}_get_{{$f.Name}} = load_class(env, { {{ExternalResourcesAsArray $m}} }, "metaffi_guest.{{index $f.FunctionPath "entrypoint_class"}}");
                {{else}}
                jclass_{{$c.Name}}_get_{{$f.Name}} = env->FindClass("metaffi_guest/{{index $f.FunctionPath "entrypoint_class"}}");
                {{end}}

                check_and_throw_jvm_exception(env, jclass_{{$c.Name}}_get_{{$f.Name}},);
                jmethod_{{$c.Name}}_get_{{$f.Name}} = env->GetStaticMethodID(jclass_{{$c.Name}}_get_{{$f.Name}}, "{{index $f.FunctionPath "entrypoint_function"}}", ("(J)V"));
                check_and_throw_jvm_exception(env, jmethod_{{$c.Name}}_get_{{$f.Name}},);
                {{end}}
                {{if $field.Setter}}{{$f := $field.Setter}}
                {{if IsExternalResources $m}}
                jclass_{{$c.Name}}_set_{{$f.Name}} = load_class(env, { {{ExternalResourcesAsArray $m}} }, "metaffi_guest.{{index $f.FunctionPath "entrypoint_class"}}");
                {{else}}
                jclass_{{$c.Name}}_set_{{$f.Name}} = env->FindClass("metaffi_guest/{{index $f.FunctionPath "entrypoint_class"}}");
                {{end}}

                check_and_throw_jvm_exception(env, jclass_{{$c.Name}}_set_{{$f.Name}},);
                jmethod_{{$c.Name}}_set_{{$f.Name}} = env->GetStaticMethodID(jclass_{{$c.Name}}_set_{{$f.Name}}, "{{index $f.FunctionPath "entrypoint_function"}}", ("(J)V"));
                check_and_throw_jvm_exception(env, jmethod_{{$c.Name}}_set_{{$f.Name}},);
                {{end}}
            {{end}}

            {{range $cstrindex, $f := $c.Constructors}}
	            {{if IsExternalResources $m}}
                jclass_{{$c.Name}}_{{$f.Name}} = load_class(env, { {{ExternalResourcesAsArray $m}} }, "metaffi_guest.{{index $f.FunctionPath "entrypoint_class"}}");
                {{else}}
                jclass_{{$c.Name}}_{{$f.Name}} = env->FindClass("metaffi_guest/{{index $f.FunctionPath "entrypoint_class"}}");
                {{end}}

	            check_and_throw_jvm_exception(env, jclass_{{$c.Name}}_{{$f.Name}},);
	            jmethod_{{$c.Name}}_{{$f.Name}} = env->GetStaticMethodID(jclass_{{$c.Name}}_{{$f.Name}}, "{{index $f.FunctionPath "entrypoint_function"}}", ("(J)V"));
	            check_and_throw_jvm_exception(env, jmethod_{{$c.Name}}_{{$f.Name}},);
            {{end}}

            {{if $c.Releaser}}{{$f := $c.Releaser}}
            {{if IsExternalResources $m}}
            jclass_{{$c.Name}}_{{$f.Name}} = load_class(env, { {{ExternalResourcesAsArray $m}} }, "metaffi_guest.{{index $f.FunctionPath "entrypoint_class"}}");
            {{else}}
            jclass_{{$c.Name}}_{{$f.Name}} = env->FindClass("metaffi_guest/{{index $f.FunctionPath "entrypoint_class"}}");
            {{end}}

            check_and_throw_jvm_exception(env, jclass_{{$c.Name}}_{{$f.Name}},);
            jmethod_{{$c.Name}}_{{$f.Name}} = env->GetStaticMethodID(jclass_{{$c.Name}}_{{$f.Name}}, "{{index $f.FunctionPath "entrypoint_function"}}", ("(J)V"));
            check_and_throw_jvm_exception(env, jmethod_{{$c.Name}}_{{$f.Name}},);
            {{end}}

            {{range $cstrindex, $f := $c.Methods}}
            {{if IsExternalResources $m}}
            jclass_{{$c.Name}}_{{$f.Name}} = load_class(env, { {{ExternalResourcesAsArray $m}} }, "metaffi_guest.{{index $f.FunctionPath "entrypoint_class"}}");
            {{else}}
            jclass_{{$c.Name}}_{{$f.Name}} = env->FindClass("metaffi_guest/{{index $f.FunctionPath "entrypoint_class"}}");
            {{end}}

            check_and_throw_jvm_exception(env, jclass_{{$c.Name}}_{{$f.Name}},);
            jmethod_{{$c.Name}}_{{$f.Name}} = env->GetStaticMethodID(jclass_{{$c.Name}}_{{$f.Name}}, "{{index $f.FunctionPath "entrypoint_function"}}", ("(J)V"));
            check_and_throw_jvm_exception(env, jmethod_{{$c.Name}}_{{$f.Name}},);
            {{end}}

        {{end}}
    {{end}}
}

{{/*
Every entrypoint calls the Java entrypoint.
The signature of the entrypoint corresponds to the expected C-function returned by load_function
*/}}


{{range $mindex, $m := .Modules}}
    {{range $cindex, $c := $m.Classes}}

        {{range $findex, $field := $c.Fields}}
            {{if $field.Getter}}{{$f := $field.Getter}}
extern "C" void EntryPoint_{{$c.Name}}_get_{{$f.Name}}({{CEntrypointParameters $f.FunctionDefinition}})
{
    {{CEntrypointCallJVMEntrypoint (print "jclass_" $c.Name "_get_" $f.Name) (print "jmethod_" $c.Name "_get_" $f.Name) $f.FunctionDefinition}}
    if_exception_throw_jvm_exception(env, releaser());
    releaser();
}
            {{end}}
            {{if $field.Setter}}{{$f := $field.Setter}}
extern "C" void EntryPoint_{{$c.Name}}_set_{{$f.Name}}({{CEntrypointParameters $f.FunctionDefinition}})
{
    {{CEntrypointCallJVMEntrypoint (print "jclass_" $c.Name "_set_" $f.Name) (print "jmethod_" $c.Name "_set_" $f.Name) $f.FunctionDefinition}}
    if_exception_throw_jvm_exception(env, releaser());
    releaser();
}
            {{end}}
        {{end}}

        {{range $cstrindex, $f := $c.Constructors}}
extern "C" void EntryPoint_{{$c.Name}}_{{$f.Name}}({{CEntrypointParameters $f.FunctionDefinition}})
{
    {{CEntrypointCallJVMEntrypoint (print "jclass_" $c.Name "_" $f.Name) (print "jmethod_" $c.Name "_" $f.Name) $f.FunctionDefinition}}
    if_exception_throw_jvm_exception(env, releaser());
    releaser();
}
        {{end}}

        {{if $c.Releaser}}{{$f := $c.Releaser}}
extern "C" void EntryPoint_{{$c.Name}}_{{$f.Name}}({{CEntrypointParameters $f.FunctionDefinition}})
{
    {{CEntrypointCallJVMEntrypoint (print "jclass_" $c.Name "_" $f.Name) (print "jmethod_" $c.Name "_" $f.Name) $f.FunctionDefinition}}
    if_exception_throw_jvm_exception(env, releaser());
    releaser();
}
        {{end}}

        {{range $cstrindex, $f := $c.Methods}}
extern "C" void EntryPoint_{{$c.Name}}_{{$f.Name}}({{CEntrypointParameters $f.FunctionDefinition}})
{
    {{CEntrypointCallJVMEntrypoint (print "jclass_" $c.Name "_" $f.Name) (print "jmethod_" $c.Name "_" $f.Name) $f.FunctionDefinition}}
    if_exception_throw_jvm_exception(env, releaser());
    releaser();
}
        {{end}}

    {{end}}
{{end}}
`
