package main

const HostHeaderTemplate = `
// Code generated by OpenFFI. DO NOT EDIT.
// Host code for {{.IDLFilenameWithExtension}}
`

const HostPackage = `package openffi;
`

const HostImports = `
import java.io.*;
import com.google.protobuf.*;
import java.util.*;
`

const HostFunctionStubsTemplate = `
{{range $mindex, $m := .Modules}}
// Code to call foreign functions in module {{$m.Name}} via XLLR

public final class {{$m.Name}}
{
	private XLLR xllr;

	public {{$m.Name}}() throws OpenFFIException, IOException
	{
		this.xllr = new XLLR();
		this.xllr.loadRuntimePlugin("xllr.{{$targetLang}}");
	}
	{{range $findex, $f := $m.Functions}}{{$ReturnValuesLength := len $f.ReturnValues}}
	public {{if eq $ReturnValuesLength 0}}void{{else if gt $ReturnValuesLength 1}}{{$f.ReturnValuesType}}{{else}}{{$elem := index $f.ReturnValues 0}}{{$elem.Type}}{{end}} {{$f.PathToForeignFunction.function}}({{range $index, $elem := $f.Parameters}} {{if $index}},{{end}}{{$elem.Type}} {{$elem.Name}}{{end}} ) throws InvalidProtocolBufferException, OpenFFIException
	{
		// serialize {{$f.ParametersType}} to protobuf
		{{$f.ParametersType}} proto{{$f.ParametersType}} =
				{{$f.ParametersType}}.newBuilder()
				{{range $index, $elem := $f.Parameters}}{{if $elem.IsArray}}.addAll{{Title $elem.Name}}(Arrays.asList({{$elem.Name}})){{else}}.set{{Title $elem.Name}}({{$elem.Name}}){{end}}{{end}}
				.build();

		CallResult cr = this.xllr.call("xllr.{{$m.TargetLanguage}}", "{{$m.Name}}", "{{$f.PathToForeignFunction.function}}", proto{{$f.ParametersType}}.toByteArray());

		// deserialize the return
        {{$f.ReturnValuesType}} ret = {{$f.ReturnValuesType}}.parseFrom(cr.out_ret);
		{{if eq $ReturnValuesLength 0}}{{else if gt $ReturnValuesLength 1}}return ret;{{else}}return ret.get{{$elem := index $f.ReturnValues 0}}{{Title $elem.Name}}();{{end}}
	}
	{{end}}
}
{{end}}
`
